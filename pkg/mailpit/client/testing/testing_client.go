// Code generated by go-swagger; DO NOT EDIT.

package testing

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new testing API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new testing API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new testing API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for testing API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithAccept allows the client to force the Accept header
// to negotiate a specific Producer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithAccept(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ProducesMediaTypes = []string{mime}
	}
}

// WithAcceptApplicationJSON sets the Accept header to "application/json".
func WithAcceptApplicationJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/json"}
}

// WithAcceptTextHTML sets the Accept header to "text/html".
func WithAcceptTextHTML(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/html"}
}

// WithAcceptTextPlain sets the Accept header to "text/plain".
func WithAcceptTextPlain(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/plain"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	GetMessageHTMLParams(params *GetMessageHTMLParamsParams, opts ...ClientOption) (*GetMessageHTMLParamsOK, error)

	GetMessageTextParams(params *GetMessageTextParamsParams, opts ...ClientOption) (*GetMessageTextParamsOK, error)

	GetChaos(params *GetChaosParams, opts ...ClientOption) (*GetChaosOK, error)

	SetChaosParams(params *SetChaosParamsParams, opts ...ClientOption) (*SetChaosParamsOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	GetMessageHTMLParams renders message HTML part

	Renders just the message's HTML part which can be used for UI integration testing.

Attached inline images are modified to link to the API provided they exist.
Note that is the message does not contain a HTML part then an 404 error is returned.

The ID can be set to `latest` to return the latest message.
*/
func (a *Client) GetMessageHTMLParams(params *GetMessageHTMLParamsParams, opts ...ClientOption) (*GetMessageHTMLParamsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetMessageHTMLParamsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetMessageHTMLParams",
		Method:             "GET",
		PathPattern:        "/view/{ID}.html",
		ProducesMediaTypes: []string{"text/html"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMessageHTMLParamsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetMessageHTMLParamsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetMessageHTMLParams: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	GetMessageTextParams renders message text part

	Renders just the message's text part which can be used for UI integration testing.

The ID can be set to `latest` to return the latest message.
*/
func (a *Client) GetMessageTextParams(params *GetMessageTextParamsParams, opts ...ClientOption) (*GetMessageTextParamsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetMessageTextParamsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetMessageTextParams",
		Method:             "GET",
		PathPattern:        "/view/{ID}.txt",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMessageTextParamsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetMessageTextParamsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetMessageTextParams: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	GetChaos gets chaos triggers

	Returns the current Chaos triggers configuration.

This API route will return an error if Chaos is not enabled at runtime.
*/
func (a *Client) GetChaos(params *GetChaosParams, opts ...ClientOption) (*GetChaosOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetChaosParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getChaos",
		Method:             "GET",
		PathPattern:        "/api/v1/chaos",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetChaosReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetChaosOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getChaos: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	SetChaosParams sets chaos triggers

	Set the Chaos triggers configuration and return the updated values.

This API route will return an error if Chaos is not enabled at runtime.

If any triggers are omitted from the request, then those are reset to their
default values with a 0% probability (ie: disabled).
Setting a blank `{}` will reset all triggers to their default values.
*/
func (a *Client) SetChaosParams(params *SetChaosParamsParams, opts ...ClientOption) (*SetChaosParamsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewSetChaosParamsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "setChaosParams",
		Method:             "PUT",
		PathPattern:        "/api/v1/chaos",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SetChaosParamsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*SetChaosParamsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for setChaosParams: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
